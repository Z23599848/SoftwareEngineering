<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Software Engineering Lecture 01 – Version Control | Roehampton</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Software Engineering Lecture 01 – Version Control" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hosts module content for computing at Roehampton." />
<meta property="og:description" content="Hosts module content for computing at Roehampton." />
<link rel="canonical" href="https://roehampton.github.io/module-content/software-engineering/week-01/lecture/" />
<meta property="og:url" content="https://roehampton.github.io/module-content/software-engineering/week-01/lecture/" />
<meta property="og:site_name" content="Roehampton" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Software Engineering Lecture 01 – Version Control" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Hosts module content for computing at Roehampton.","headline":"Software Engineering Lecture 01 – Version Control","url":"https://roehampton.github.io/module-content/software-engineering/week-01/lecture/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/module-content/assets/css/style.css?v=ea56b5ca3cc64b80129c924758c62c92b98b36d5">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/module-content/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      

      <h1 id="software-engineering-lecture-01--version-control">Software Engineering Lecture 01 – Version Control</h1>

<h2 id="what-is-version-control">What is Version Control</h2>

<p>Version control is about the management of changes to documents or collections of information.  Although you might think of version control as an inherently software development tool, it can be used for anything really.  From a software development perspective, version control is a component of <strong>Software Configuration Management (SCM)</strong>.  Git’s main website has the address <a href="https://git-scm.com/">https://git-scm.com/</a> as it is a part of SCM.</p>

<p>Version control is embedded in a number of tools.  For example, Google Docs automatically versions your document as you make edits:</p>

<p><img src="/module-content/software-engineering/week-01/lecture/google-doc-version.png" alt="Google Doc Versioning" /></p>

<p>Track changes and similar functionality exists in Microsoft Word.  The key point is that version management is seen as a key feature of documents in general, not just software.  It allows two key pieces of meta-data to be tracked:</p>

<ol>
  <li><strong>When</strong> a change was made.</li>
  <li><strong>Who</strong> made the change.</li>
</ol>

<p>Both pieces of information allow us to track back to where problems arose, and know where to fix the issue.  When working in a team this information can be fundamental to ensure everyone is working on the same version of the document, or at least know which changes have been made between different working versions.</p>

<p>Another key idea in version control is that we can return to previous versions of our document.  Therefore, if we make an error (e.g. add a bug) we can <strong>rewind</strong> to the previous version - or any previous version - and continue our work from there:</p>

<p><img src="/module-content/software-engineering/week-01/lecture/rewind.png" alt="Version Control Rewind" /></p>

<p>A further idea is the concept of working and managing multiple versions of the document using a concept called <strong>branching</strong>.  Different branches allow different versions of the information to be worked on discretely by several people.  When work needs to be combined we can <strong>merge</strong> the information together into one of the branches:</p>

<p><a href="https://commons.wikimedia.org/wiki/File:Revision_controlled_project_visualization-2010-24-02.svg#/media/File:Revision_controlled_project_visualization-2010-24-02.svg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Revision_controlled_project_visualization-2010-24-02.svg/1200px-Revision_controlled_project_visualization-2010-24-02.svg.png" alt="Revision controlled project visualization-2010-24-02.svg" /></a><br />By <a href="//commons.wikimedia.org/wiki/File:Revision_controlled_project_visualization.svg" title="File:Revision controlled project visualization.svg">Revision_controlled_project_visualization.svg</a>: *<a href="//commons.wikimedia.org/wiki/File:Subversion_project_visualization.svg" title="File:Subversion project visualization.svg">Subversion_project_visualization.svg</a>: Traced by <a href="//commons.wikimedia.org/wiki/User:Stannered" title="User:Stannered">User:Stannered</a>, original by <a href="https://en.wikipedia.org/wiki/User:Sami_Kerola" class="extiw" title="en:User:Sami Kerola">en:User:Sami Kerola</a>
derivative work: <a href="//commons.wikimedia.org/wiki/User:Moxfyre" title="User:Moxfyre">Moxfyre</a> (<a href="//commons.wikimedia.org/wiki/User_talk:Moxfyre" title="User talk:Moxfyre"><span class="signature-talk">talk</span></a>)
derivative work: <a href="//commons.wikimedia.org/w/index.php?title=User:Echion2&amp;action=edit&amp;redlink=1" class="new" title="User:Echion2 (page does not exist)">Echion2</a> (<a href="//commons.wikimedia.org/wiki/User_talk:Echion2" title="User talk:Echion2"><span class="signature-talk">talk</span></a>) - <a href="//commons.wikimedia.org/wiki/File:Revision_controlled_project_visualization.svg" title="File:Revision controlled project visualization.svg">Revision_controlled_project_visualization.svg</a>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=9562807">Link</a></p>

<h3 id="popular-version-control-tools">Popular Version Control Tools</h3>

<p>There are many version control tools available to the software engineer.  A few of the more popular ones are:</p>

<ul>
  <li><a href="https://git-scm.com/"><strong>Git</strong></a> which is commonly associated with popular repository sites such as <a href="https://github.com/"><strong>GitHub</strong></a>, <a href="https://about.gitlab.com/"><strong>GitLab</strong></a>, and <a href="https://bitbucket.org/"><strong>Bitbucket</strong></a>.  Git is independent of these platforms and should not be confused with them.</li>
  <li><a href="https://www.mercurial-scm.org/"><strong>Mercurial</strong></a> is a popular alternative to Git, and developed as a replacement for <em>BitKeeper</em> which itself led to the development of Git.  The history of why BitKeeper is not popular and led to both Git and Mercurial is <a href="https://en.wikipedia.org/wiki/BitKeeper">interesting</a>.  Mercurial, although less well known, is used by big organisations such as Facebook and Mozilla.</li>
  <li><a href="https://subversion.apache.org/"><strong>Subversion (SVN)</strong></a> which is an <em>Apache</em> project that derived from an older tool called <em>Concurrent Versions System (CVS)</em>.</li>
</ul>

<h3 id="version-control-approaches">Version Control Approaches</h3>

<p>There are three approaches a Version Control System (VCS) can take:</p>

<ul>
  <li><strong>Localised</strong>, which means developers must be working on the same file-system.  These were early approaches and no longer relevant today.</li>
  <li><strong>Client-server</strong> where multiple developers (<em>clients</em>) can work locally and push changes to a single server repository.</li>
  <li><strong>Distributed</strong> where the complete code-base and history is stored by each developer locally, thus replicating the repository.  Developers can collaborate via remote repositories - such as on GitHub.</li>
</ul>

<p><em>Git is a distributed approach.</em></p>

<h3 id="some-terminology">Some Terminology</h3>

<p>Before looking at the history of version control let us define some common terms in a VCS:</p>

<ul>
  <li><strong>Repository</strong> is where the code and history is stored.  In a <em>client-server</em> model this is on the server.  In a <em>distributed</em> model this is any local version.</li>
  <li><strong>Checkout</strong> or <strong>clone</strong> is the process of getting a copy of the code from the repository.  In a <em>client-server</em> model, we <em>checkout</em> the code.  In a <em>distributed</em> model, we <em>clone</em> the entire repository, including the history.</li>
  <li><strong>Working copy</strong> is the local version of the code-base.  We can make any changes we want to the working copy as it is not reflected anywhere else - it is a sandbox.</li>
  <li><strong>Fetch</strong> or <strong>pull</strong> is to get the most recent version of the code-base from the remote repository.  In <em>Git</em>, <em>fetch</em> and <em>pull</em> are different in that pull will also merge any changes into the local working copy.</li>
  <li><strong>Push</strong> is when we push our local changes to the remote repository.  To do this we have to create a commit.</li>
  <li><strong>Commit</strong> is a new version of the code-base.  Typically a commit contains the changes added in the local <em>working copy</em> which can then be sent to the remote repository if need be.  In <em>distributed</em> models, working copies are repositories, so we can undertake numerous commits before pushing all the changes to the remote repository.</li>
  <li><strong>Tag</strong> or <strong>label</strong> is extra information we can add to a particular commit, such as <code class="language-plaintext highlighter-rouge">v0.1.0</code>.</li>
  <li><strong>Head</strong> is a special <em>tag</em> or <em>label</em> for the most recent <em>commit</em> on a <em>branch</em>.</li>
  <li><strong>Branch</strong> is another version of the code-base.  Branches are independent, meaning they can be worked on without causing conflicts.  We <em>merge</em> branches when we wish to synchronise them.</li>
  <li><strong>Main</strong> or <strong>trunk</strong> is the name of the main <em>branch</em> in a repository.  Git uses the term <em>main</em> and SVN uses the term <em>trunk</em>.</li>
  <li><strong>Merge</strong> is the process of combining one <em>branch</em> into another.  Any differences between files in the branches have to be resolved before the merge can be completed.</li>
  <li><strong>Conflict</strong> occurs when different change versions of the same document exist while merging branches which must be fixed.</li>
  <li><strong>Resolve</strong> is the process of fixing <em>conflicts</em>.  There are tools that can support this process, but it does require human intervention.</li>
</ul>

<h2 id="what-is-git">What is Git?</h2>

<p>Git is a <strong>distributed VCS</strong> where developers clone a complete copy of the repository, including its history, within the local file system.  Born from the <em>BitKeeper Controversy</em>, Linus Torvalds wanted a system that was fast.  He used three points to drive the design of Git:</p>

<ol>
  <li>See Concurrent Versions System (CVS) as the model of what <strong>not</strong> to do.</li>
  <li>Support a distributed workflow, as in BitKeeper.</li>
  <li>Have strong safeguards against corruption.</li>
</ol>

<p>So, Git has the following properties:</p>

<ol>
  <li>It is fast.</li>
  <li>It has data integrity features.</li>
  <li>It is distributed, thus supporting non-linear workflows.</li>
</ol>

<p>Git is likely the most popular and well known VCS at the moment, although this is partly due to the popularity of GitHub.  The two are often confused, but there is no link between the two beyond GitHub supporting Git repositories.</p>

<p>Let us move onto the principles of Git, which will provide a deeper understanding of how Git works.</p>

<h2 id="principles-of-git">Principles of Git</h2>

<p>The following section will step through numerous principles in Git with the relevant commands.  We will look at the basics of repositories, basic workflow for submitting changes, the basic workflow for fetching and merging changes, and the basics of branching.</p>

<h3 id="working-with-repositories">Working with Repositories</h3>

<p>Git works with <em>repositories</em>.  A repository is the code and history of a code-base.  Every time you work with Git you are working within a repository: your local repository.  You may also work with some remote repositories.  That is a key idea with Git - your local machine working copy is also a repository.</p>

<p>You can create your local repository in one of two ways:</p>

<ol>
  <li>Initialise an empty repository using <code class="language-plaintext highlighter-rouge">git init</code> in a folder.</li>
  <li>Call <code class="language-plaintext highlighter-rouge">git clone &lt;url&gt;</code> to clone an existing repository from a remote repository as shown below:</li>
</ol>

<p><img src="/module-content/software-engineering/week-01/lecture/git-clone.png" alt="Git Clone" /></p>

<p>When you <em>clone</em> a repository you also set up a link to the remote repository called <code class="language-plaintext highlighter-rouge">origin</code>.  We will discuss <a href="#Remotes">remotes later</a>.</p>

<p>There is a special version of empty initialisation: <code class="language-plaintext highlighter-rouge">git init --bare</code>.  This is usually used on a server that is used to coordinate teams.  In general, you should <em>not</em> use <code class="language-plaintext highlighter-rouge">git init --bare</code>.</p>

<h3 id="working-with-changes">Working with Changes</h3>

<p>A Git repository is a folder which contains a hidden folder (<code class="language-plaintext highlighter-rouge">.git</code>).  The hidden folder contains the history and other status information of the repository.  Otherwise, the repository just looks like a folder - there is nothing extra managed.</p>

<p>Whenever you add, remove or edit a file in the repository, Git can tell based on the information in the hidden <code class="language-plaintext highlighter-rouge">.git</code> folder.  Any changes at this point are not saved by Git.  To save the changes, we have to go through two steps:</p>

<ol>
  <li><strong>Add</strong> the changes we want to save at this point.</li>
  <li><strong>Commit</strong> the changes to the repository.</li>
  <li>(optional) <strong>Push</strong> the changes to the remote(s).</li>
</ol>

<h4 id="adding-changes">Adding Changes</h4>

<p>Before step 1 (adding changes) we are in a working files state.  We are editing files and working on our code but not ready to store the changes long term.  This is usually because we are not finished whatever change we have in mind.</p>

<p>Once we are ready to add the changes we can use the following command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git add &lt;filename&gt;
</code></pre></div></div>

<p>We can name each file individually, name a folder, or use a wildcard (e.g., <code class="language-plaintext highlighter-rouge">git add *</code>).  In any case, we have moved changes from the working area to the <strong>staging area</strong>.</p>

<p>We can see files that are different from the currently Git version or staged using the following command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git status
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">git status</code> is useful for keeping track of the work we are doing.  You should use it often to remind yourself what you are doing.</p>

<p>Once we have added all the changes we want for a particular feature/task, we create a <strong>commit</strong>.</p>

<h4 id="committing-changes">Committing Changes</h4>

<p>A <strong>commit</strong> is just a group of changes.  A commit operation takes the changes currently in the staging area and creates a new <strong>snapshot</strong> of our code at this point.  Git stores this snapshot in its history.  To create a commit, we use the following:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit <span class="nt">-m</span> <span class="s2">"&lt;message&gt;"</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">message</code> should be informative about what the changes are.  A <code class="language-plaintext highlighter-rouge">message</code> should ideally be simple and to the point (e.g., do not use the word <em>and</em> if you can avoid it).  The messages allow others to see the changes made and (hopefully) why, thus providing more information to your fellow software developers.</p>

<p>A commit is a store piece of history, and Git keeps track of all the history in a repository.  This actually has an advantage - <em>you can ask Git to go back to a previous version</em>.  In simple terms, Git provides you with a big rewind button that allows you to go back to previous versions of your code, so as advice:</p>

<ul>
  <li>Create commits often, from simple little changes that don’t break the build.</li>
  <li>Experiment in the comfort that you can always go back to a previous working version of your application.</li>
</ul>

<p>The big idea is to <strong>commit often</strong>.  Commits allow you to <strong>checkout</strong> a previous commit if anything goes wrong.  <em>But always ensure your commit works!</em></p>

<h4 id="pushing-changes">Pushing Changes</h4>

<p>Any commit created on your machine is only stored locally.  So, although you have been keeping a good record of your changes locally, they can not be seen by others.  Your changes have also not been stored on a remote server.  To do this, we use the <code class="language-plaintext highlighter-rouge">git push</code> command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">git push</code> will push the current branch (e.g., <code class="language-plaintext highlighter-rouge">master</code>) to the current remote (normally <code class="language-plaintext highlighter-rouge">origin</code>).  You can be more explicit with a push:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push &lt;remote&gt; &lt;branch&gt;
</code></pre></div></div>

<p>For example, it is common to see <code class="language-plaintext highlighter-rouge">git push origin master</code>.  This will push your local version of branch <code class="language-plaintext highlighter-rouge">master</code> to the <code class="language-plaintext highlighter-rouge">origin</code> remote.</p>

<p>There are other options with <code class="language-plaintext highlighter-rouge">git push</code> such as:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git push --force</code> forces your local branch version to become the remote’s.  <strong>Not recommended!</strong></li>
  <li><code class="language-plaintext highlighter-rouge">git push --all</code> pushes updates to all local branches to the remote.  Useful shortcut if needed.</li>
</ul>

<h4 id="diffs">Diffs</h4>

<p>Git keeps track of history by storing the <em>differences</em> between files.  We can simplify a difference to four types:</p>

<ol>
  <li>The addition of a new file and its initial contents.</li>
  <li>The removal of a file.</li>
  <li>The addition of new lines to a file.</li>
  <li>The removal of lines from a file.</li>
</ol>

<p>If you edit a line it is considered a new line addition and the old line being removed.  To see the changes made, we can use the <code class="language-plaintext highlighter-rouge">git diff</code> command:</p>

<p><img src="/module-content/software-engineering/week-01/lecture/diff.png" alt="Git Difference Between Two Files" /></p>

<p>As Git tracks changes as line additions and removals, it is very good at monitoring text files (such as code files).  It is very bad at binary data such as executables and images.  A couple of rules:</p>

<ul>
  <li><strong>Do not store executables in your Git repository</strong> - even those built by the project.</li>
  <li><strong>Be careful when working with media files</strong> - only store versions that will not change.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">.git</code> folder contains all the changes, and so a repository can become large if you do not behave yourself.  If your repository becomes many megabytes in size you are probably tracking something you should not be.</p>

<h4 id="git-log">Git Log</h4>

<p>Once we have some commits, we can ask Git to provide us with the history of commits in the <strong>Git Log</strong>.  To open the log use the <code class="language-plaintext highlighter-rouge">log</code> command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">log</code> opens the Git log file, for example:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>commit e426d2c1b1aa7f732c5b863708de4e3a29da3b52 <span class="o">(</span>HEAD -&gt; feature/lecture03, origin/feature/lecture03<span class="o">)</span>
Author: Kevin Chalmers &lt;k.chalmers@napier.ac.uk&gt;
Date:   Wed Aug 15 16:32:59 2018 +0100

    Almost completed section on adding changes to lecture 03.

commit b53479816d69a0d6254f9501d636f6b6e75460fb
Author: Kevin Chalmers &lt;k.chalmers@napier.ac.uk&gt;
Date:   Thu Aug 9 15:23:16 2018 +0100

    Added working with repositories section.

commit b9001d50cc976e70a150d129fe5aeb9e67e8c210
Author: Kevin Chalmers &lt;k.chalmers@napier.ac.uk&gt;
Date:   Thu Aug 9 15:11:29 2018 +0100

    Spell check.

commit dcbc34b2d990f768317c7e7a684b1de037ac199c
Author: Kevin Chalmers &lt;k.chalmers@napier.ac.uk&gt;
Date:   Thu Aug 9 14:31:58 2018 +0100
</code></pre></div></div>

<p>The hex value is the <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> hash of the commit which Git generates automatically for every commit you make. The SHA-1 hash is after the word <strong>commit</strong>.</p>

<p>A better way to use <code class="language-plaintext highlighter-rouge">log</code> is to display simple information.  For example, we can provide the information on one line</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--pretty</span><span class="o">=</span>oneline
</code></pre></div></div>

<p>Which provides the following:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>e426d2c1b1aa7f732c5b863708de4e3a29da3b52 <span class="o">(</span>HEAD -&gt; feature/lecture03, origin/feature/lecture03<span class="o">)</span> Almost completed section on adding changes to lecture 03.
b53479816d69a0d6254f9501d636f6b6e75460fb Added working with repositories section.
b9001d50cc976e70a150d129fe5aeb9e67e8c210 Spell check.
dcbc34b2d990f768317c7e7a684b1de037ac199c Added intro to git.
bc03649d4aee053ddd3174676484ee7c6aaaafb0 Fix to image file.
9dbd514068d6af135b55e8e7e49181c38e831b19 Fix to image file.
</code></pre></div></div>

<p>The SHA-1 hash can be shortened to a more usable version as follows:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--pretty</span><span class="o">=</span><span class="s2">"%h %s"</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">%h</code> will provide the short SHA-1 hash, and <code class="language-plaintext highlighter-rouge">%s</code> the commit message:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>e426d2c Almost completed section on adding changes to lecture 03.
b534798 Added working with repositories section.
b9001d5 Spell check.
dcbc34b Added intro to git.
bc03649 Fix to image file.
9dbd514 Fix to image file.
</code></pre></div></div>

<h4 id="going-backwards">Going Backwards</h4>

<p>Once you have a chain of commits it is possible to go backwards through our work.  There are various methods to return to previous states of the repository - some of which can be destructive.  We will look at the basic approach which is non-destructive.</p>

<p>Git provides a command - <code class="language-plaintext highlighter-rouge">checkout</code> - that allows you to revert to a previous commit.  It has the following form:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout &lt;<span class="nb">hash</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">&lt;hash&gt;</code> value is the SHA-1 hash from the log.  You can use the shortened hash:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout b9001d5
</code></pre></div></div>

<p>Checking out previous commits allows you to revert to a previous repository state which may fix errors with your work.  The ability to go backwards is one of the key features of version control.</p>

<h3 id="fetching-and-merging-changes">Fetching and Merging Changes</h3>

<p>When multiple people are working on a single code-base we often want to take their changes and merge them into our own.  There are essentially two methods to do this:</p>

<h4 id="fetch-and-merge">Fetch and Merge</h4>

<p>We can fetch the current version of the remote repository using the <code class="language-plaintext highlighter-rouge">fetch</code> command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git fetch &lt;remote&gt;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;remote&gt;</code> is the name of the remote repository you want to fetch from - in the initial case this will likely be <code class="language-plaintext highlighter-rouge">origin</code>:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git fetch origin
</code></pre></div></div>

<p>We can also fetch from different branches or from everything.</p>

<p>A <code class="language-plaintext highlighter-rouge">fetch</code> operation does not do anything to change the files you are working with.  <code class="language-plaintext highlighter-rouge">fetch</code> simply gets the remote history.  To see any changes you have to <code class="language-plaintext highlighter-rouge">merge</code>:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git merge &lt;branch&gt;
</code></pre></div></div>

<p>To start with you will likely use <code class="language-plaintext highlighter-rouge">origin/master</code> to merge the <code class="language-plaintext highlighter-rouge">master</code> branch from the <code class="language-plaintext highlighter-rouge">origin</code> remote:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git merge origin/master
</code></pre></div></div>

<p>You will now be able to see any changes made to the remote repository in your local files.</p>

<p>Merging with <code class="language-plaintext highlighter-rouge">merge</code> is also how you combine changes from one branch into another.  For example, say you are working on a <code class="language-plaintext highlighter-rouge">feature</code> branch and want to merge the changes there into the main <code class="language-plaintext highlighter-rouge">master</code> branch.  To do so we must perform the following steps:</p>

<ol>
  <li>Commit any changes to the <code class="language-plaintext highlighter-rouge">feature</code> branch.</li>
  <li>Checkout the <code class="language-plaintext highlighter-rouge">master</code> branch.</li>
  <li>Merge the <code class="language-plaintext highlighter-rouge">feature</code> branch into the <code class="language-plaintext highlighter-rouge">master</code> branch.</li>
</ol>

<p>The commands for 2. and 3. are:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout master
git merge feature
</code></pre></div></div>

<p>We will look at branching presently.</p>

<h4 id="pulling">Pulling</h4>

<p>Fetching and merging provide a fine-grained control over managing changes, but often you just want to get the most recent updates without any worry.  To do this, we use the <code class="language-plaintext highlighter-rouge">pull</code> command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git pull
</code></pre></div></div>

<p>And that is it.  <code class="language-plaintext highlighter-rouge">pull</code> will perform the fetching and merging (if it can) for you.  Generally, as a beginner you will find <code class="language-plaintext highlighter-rouge">pull</code> provides the functionality you need.</p>

<h4 id="managing-conflicts">Managing Conflicts</h4>

<p>Problems arise when you have changed a file that has also been changed by someone else.  Managing conflicts can be a tricky business, and rather than try to explain it here we will provide a <a href="https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/">reference</a> for you to read.</p>

<h3 id="branching">Branching</h3>

<p>A powerful technique of version control is the ability to create different <em>branches</em>.  A <strong>branch</strong> is a new <em>version</em> of the code that is independent to other branches, including the main one.  For example:</p>

<p><img src="branches.PNG" alt="Git Branches" /></p>

<p>Here, four branches are in operation.  The one on the left will be <code class="language-plaintext highlighter-rouge">master</code>.  From this two further branches were made, and from one of these a further branch, leading to four.  Each have their own commits and therefore history.</p>

<p>To create a branch we use the following command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch &lt;name&gt;
</code></pre></div></div>

<p>This will create a new branch with the given name from the current state of the repository.  We then need to switch to that branch:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout &lt;name&gt;
</code></pre></div></div>

<p>This will switch to (<code class="language-plaintext highlighter-rouge">checkout</code>) the new branch, and allow you to work in a new unique instance of the codebase.  You can do both operations at once:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">-b</span> &lt;name&gt;
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">-b</code> flag also creates a branch while switching.</p>

<p>Once you have a new branch and do some work on it, we will want to <strong>merge</strong> these changes back into single branch - this is the collaborative nature of version control.  To combine branches we do the following:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git merge &lt;name&gt;
</code></pre></div></div>

<p>This will merge the named branch into the current branch.  We can now define a typical branching workflow:</p>

<ol>
  <li>Create a new branch and check it out - <code class="language-plaintext highlighter-rouge">git checkout -b my_branch</code>.</li>
  <li>Do some work.</li>
  <li>Add necessary changes to the commit - <code class="language-plaintext highlighter-rouge">git add *</code> for example.</li>
  <li>Commit the changes - <code class="language-plaintext highlighter-rouge">git commit -m "Did some changes"</code>.</li>
  <li>Checkout the original branch - <code class="language-plaintext highlighter-rouge">git checkout master</code> for example.</li>
  <li>Perform the merge - <code class="language-plaintext highlighter-rouge">git merge my_branch</code>.</li>
  <li>Commit the new changes to the original branch - <code class="language-plaintext highlighter-rouge">git commit -m "Merged with my_branch"</code>.</li>
  <li>Push the changes to the main remote - <code class="language-plaintext highlighter-rouge">git push</code>.</li>
</ol>

<p>Steps 2-4 are repeated until you are ready to do the final merge - <strong>do not merge every small change</strong>.  The point is that changes are isolated and kept to the branch they are being undertaken in.</p>

<h3 id="remotes">Remotes</h3>

<p>A final command we will look at is <code class="language-plaintext highlighter-rouge">git remote</code>.  This allows us to view or add remotes.  A remote is just a remote repository - such as a GitHub one.  Remote repositories are used for collaboration.  To view the current remote we use the raw command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote
</code></pre></div></div>

<p>Which will display the name of the current remote, e.g.,:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>origin
</code></pre></div></div>

<p>We can also list all current remotes:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote <span class="nt">-v</span>
</code></pre></div></div>

<p>For example:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>origin  https://github.com/kevin-chalmers/set08103.git <span class="o">(</span>fetch<span class="o">)</span>
origin  https://github.com/kevin-chalmers/set08103.git <span class="o">(</span>push<span class="o">)</span>
</code></pre></div></div>

<p>And to add a new remote we use the following command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote add &lt;name&gt; &lt;url&gt;
</code></pre></div></div>

<p>This will add a new remote with the given name using the given URL.  We can now push and pull from this remote using the given name.</p>

<h3 id="ignoring-files">Ignoring Files</h3>

<p>A final piece of functionality is ignoring files.  It is often the case that the build system and other functions will generate files we do not want to store in our repository.  Binary files are such an example.</p>

<p>To ignore files, we specify a <code class="language-plaintext highlighter-rouge">.gitignore</code> file.  This file uses wildcards, folder names, etc. to specify files to ignore.</p>

<h3 id="a-simple-git-workflow">A Simple Git Workflow</h3>

<ol>
  <li>Modify files to make a working change.</li>
  <li>Add changes to the staging area with <code class="language-plaintext highlighter-rouge">git add</code>.</li>
  <li>Create a commit from the changes with <code class="language-plaintext highlighter-rouge">git commit</code>.</li>
  <li>Send the changes to the remote with <code class="language-plaintext highlighter-rouge">git push</code>.</li>
</ol>

<h3 id="summary">Summary</h3>

<p>The following diagram attempts to summarise some of the concepts we have looked at in this lecture:</p>

<p><a href="https://commons.wikimedia.org/wiki/File:Git_operations.svg#/media/File:Git_operations.svg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/Git_operations.svg/1200px-Git_operations.svg.png" alt="Git operations.svg" /></a><br />By <a href="//commons.wikimedia.org/wiki/User:Duesentrieb" title="User:Duesentrieb">Daniel Kinzler</a> - <span class="int-own-work" lang="en">Own work</span>, <a href="https://creativecommons.org/licenses/by/3.0" title="Creative Commons Attribution 3.0">CC BY 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=25223536">Link</a></p>

<p>We have covered the following commands:</p>

<table>
  <thead>
    <tr>
      <th>Command</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">init</code></td>
      <td>Initialises a new Git repository.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">clone</code></td>
      <td>Clones an existing Git repository.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add</code></td>
      <td>Adds files to a the staging area for a commit.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">status</code></td>
      <td>Gets the current status of the Git repository.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">commit</code></td>
      <td>Creates a new commit (checkpoint) in the code base.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">push</code></td>
      <td>Pushes changes (commits) to a remote.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">diff</code></td>
      <td>Provides information on differences between commits.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">log</code></td>
      <td>Provides history of Git commits.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">checkout</code></td>
      <td>Switches to a given branch or commit.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fetch</code></td>
      <td>Fetches changes from a remote repository.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">merge</code></td>
      <td>Merges changes from another branch into the current one.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pull</code></td>
      <td>Fetches and merges changes.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">branch</code></td>
      <td>Creates a new branch.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remote</code></td>
      <td>Allows working with (e.g., adding, listing) remotes for the current repository.</td>
    </tr>
  </tbody>
</table>

<h2 id="summary-1">Summary</h2>

<p>We have covered a lot in this lecture:</p>

<ul>
  <li>Defined what version control is.</li>
  <li>Described the key differences between client-server and distributed VCS.</li>
  <li>Defined what Git is.</li>
  <li>Listed the basic Git commands.</li>
</ul>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
  </body>
</html>
